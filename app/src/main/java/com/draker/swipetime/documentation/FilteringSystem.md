# Система фильтрации контента в SwipeTime

## Общая информация

Система фильтрации контента в SwipeTime позволяет пользователям настраивать отображаемые карточки в соответствии со своими предпочтениями. Пользователи могут фильтровать контент по жанрам, странам, языкам, годам выпуска, продолжительности и другим параметрам.

## Компоненты системы фильтрации

### 1. Модель данных (Entity)

`UserPreferencesEntity` - класс, который хранит предпочтения пользователя:
- `preferredGenres` - предпочитаемые жанры
- `preferredCountries` - предпочитаемые страны
- `preferredLanguages` - предпочитаемые языки
- `interestsTags` - теги интересов
- `minDuration` и `maxDuration` - диапазон продолжительности
- `minYear` и `maxYear` - диапазон годов выпуска
- `adultContentEnabled` - показывать ли контент 18+

### 2. DAO и репозиторий

`UserPreferencesDao` - интерфейс для работы с базой данных предпочтений пользователя.
`UserPreferencesRepository` - репозиторий для работы с предпочтениями пользователя.

### 3. ViewModel

`FilterViewModel` - ViewModel для управления настройками пользователя и фильтрации контента.

### 4. Фрагменты и UI

`FilterSettingsFragment` - фрагмент для настройки фильтров.
`CardStackFragment` - фрагмент для отображения карточек с применением фильтров.

### 5. Утилитарные классы

`ContentFilterHelper` - класс для фильтрации контента по предпочтениям пользователя.
`CardFilterIntegrator` - класс для интеграции фильтров с системой отображения карточек.
`RecommendationEngine` - движок рекомендаций для сортировки контента по релевантности.

## Как работает фильтрация

1. Пользователь настраивает свои предпочтения в `FilterSettingsFragment`
2. Предпочтения сохраняются в базе данных через `UserPreferencesRepository`
3. `CardStackFragment` при загрузке или обновлении проверяет, есть ли у пользователя активные фильтры
4. Если фильтры активны, `CardFilterIntegrator` применяет их к списку контента
5. `ContentFilterHelper` выполняет фактическую фильтрацию по критериям
6. `RecommendationEngine` сортирует отфильтрованные элементы по релевантности
7. Отфильтрованный и отсортированный список отображается в `CardStackView`

## Хранение предпочтений

Предпочтения пользователя хранятся в базе данных Room. Списки (жанры, страны, языки, теги) хранятся в формате JSON строк.

## Алгоритм рекомендаций

Текущий алгоритм рекомендаций является простым:
1. Каждый элемент получает базовый рейтинг релевантности 1.0
2. Рейтинг увеличивается за совпадения с предпочтениями пользователя:
   - За каждый совпадающий жанр +0.5
   - За совпадение страны +0.2
   - За совпадение языка +0.2
   - За совпадение тегов интересов +0.2
3. Дополнительные факторы:
   - Более новые произведения получают бонус до +0.3
   - Произведения с высоким рейтингом получают бонус до +0.5
4. Элементы сортируются по убыванию релевантности

## Расширение системы фильтрации

### Добавление новых фильтров

1. Добавьте поля в `UserPreferencesEntity`
2. Обновите методы в `UserPreferencesDao`
3. Добавьте методы работы с новыми фильтрами в `UserPreferencesRepository`
4. Добавьте UI элементы в `FilterSettingsFragment`
5. Добавьте обработку новых фильтров в `ContentFilterHelper`
6. При необходимости, обновите алгоритм рекомендаций в `RecommendationEngine`

### Усовершенствование рекомендаций

Для улучшения качества рекомендаций можно реализовать:
1. Коллаборативную фильтрацию
2. Контентную фильтрацию
3. Гибридные подходы
4. Машинное обучение для прогнозирования предпочтений пользователя

## Интеграция с внешними API

При интеграции с внешними API (TMDb, RAWG и др.) необходимо:
1. Добавить поля для хранения идентификаторов API в сущности
2. Расширить логику фильтрации для работы с новыми данными
3. Обновить алгоритм рекомендаций для учета новых данных
